head(assay(treatments, 'coverage'))
##This section selects nucleotide positions in each experimental replicate from which
#LDRs will be calculated, using the selectNuclPos function. It takes in the coverage
#and DOC info from se, the numbers of control (Nc) and treatment (Nt) replicates, and
#user-specified coverage threshold. Nucleotides with coverage < t are eliminated.
Nc <- Nt <- noreplicates
t <- 1
nuclSelection <- selectNuclPos(se, Nc, Nt, t)
List(nuclSelection)
##this is just a calculator that returns the combinations we can make
#of n elements when taken m at a time. Here it just means we want to find the number
#of comparisons we can make when there Nc replicates. It returns the indices of the
#replicates for each possible combination.
t(combn(Nc, 2))
##selectNuclPos returns lists that hold the positional information for the nucleotide
#pairs that can be used to compute log ratios, in analysedC and analysed CT
#the number of matrices printed out by calling nuclSelection$analysedC or CT,
#correspond to the number of C-C/T-C comparisons that can be made between replicates.
length(nuclSelection$analysedC[[1]])
length(nuclSelection$analysedCT[[1]])
## Finds the medians of original drop-off rates in each experimental replicate
apply(assay(se, 'dropoff_rate'), 2, median)
## This is a normalization strategy, to ensure the distribution of drop-off rates are
#similar between replicates. Here we scale drop-off rates of the nucleotides selected for pairwise
#comparisons to have a common median value.
assay(se, "dropoff_rate") <- scaleDOR(se, nuclSelection, Nc, Nt)
## just a print out to confirm if medians of scaled drop-off rates between
#replicates have become more similar
apply(assay(se, 'dropoff_rate'), 2, median)
## ------------------------------------------------------------------------
##The computeStretches function finds uninterrupted stretches of nucleotides to be
#used for calculation of posterior probabilites. It returns an IRanges object
#called "stretches", a matrix which contains the index ranges and width
#of the uninterrupted stretches.
stretchestwo <- computeStretches(se, t)
## ------------------------------------------------------------------------
head(stretchestwo)
#assay(se, 'dropoff_count')[1748,]
## ------------------------------------------------------------------------
#corrects the log-ratios for any dependency on coverage, to correct for coverage
#bias. This is also the part where the log drop-off ratios are calculated.
varStab <- stabiliseVariance(se, nuclSelection, Nc, Nt)
LDR_C <- varStab$LDR_C
LDR_CT <- varStab$LDR_CT
#storing the
LDR_C_2 <- LDR_C
LDR_CT_2 <-LDR_CT
head(LDR_C_2)
head(LDR_CT_2)
#prints out the null distribution histogram, the argument breaks is use to define
#number of bins we want to break the data up into
hist(LDR_C, breaks = 30, main = 'Null distribution of LDRs')
## ------------------------------------------------------------------------
#considering that immediate neighbours of a nucleotide can affect accessibility,
#we want to remove the effect of sequence on nucleotides' susceptibility
#to chemical modification.This is done by computing different null distributions
#for user-defined sequence patterns. This step is omitted for the 18S.
nuclNum <- 3
patterns <- nuclPerm(nuclNum)
patterns
## ------------------------------------------------------------------------
## Extract the DNA sequence
sequence <- subject(rowData(se)$nucl)
sequence
nuclPosition <- findPatternPos(patterns, sequence, '+')
patterns[[1]]
head(nuclPosition[[1]])
## ------------------------------------------------------------------------
#Skip to here for 18S. Here we are using all the nucleotide positions for constructing
#a single null distribution for quantifying drop-off rate variability. We specify
#nuclPosition list to contain 1 element ([1]), corresponding to the single stretch
#of reference DNA sequence
nuclPosition <- list()
nuclPosition[[1]] <- 2:nchar(sequence)
## Start of the stretch
nuclPosition[[1]][1]
## End of the stretch, gives the length of the stretch of nucleotides
nuclPosition[[1]][length(nuclPosition[[1]])]
## ------------------------------------------------------------------------
###check if the matrices of p-values can be called after the pipeline has been run twice
head(LDR_C_1)
head(LDR_CT_1)
head(LDR_C_2)
head(LDR_CT_2)
## ------------------------------------------------------------------------
###computes posterior probabilities of all nucleotides in the stretch specified above.
#This is the step where the null distributions and p-values are calculated as well.
#The most important arguments are the LDRs, the positions used to compute the
#null distribution, as well as the positional information of the selected stretches
#and nucleotide pairs where the LDRs were obtained
stretches <-overlapsRanges(stretchesone,stretchestwo)
head(stretches)
empPvals_1 <- computePvals(LDR_C_1, LDR_CT_1, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
empPvals_2 <- computePvals(LDR_C_2, LDR_CT_2, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
index_1<-is.na(empPvals_1)
index_2<-is.na(empPvals_2)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+',stretches)
## ------------------------------------------------------------------------
dim(posteriors_diff)
print(posteriors_diff [1:4,])
stretches <-overlapsRanges(stretchesone,stretchestwo)
head(stretches)
empPvals_1 <- computePvals(LDR_C_1, LDR_CT_1, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
empPvals_2 <- computePvals(LDR_C_2, LDR_CT_2, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
index_1<-is.na(empPvals_1)
index_2<-is.na(empPvals_2)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+',stretches)
source("computeposteriors.R")
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+',stretches)
source("https://bioconductor.org/biocLite.R")
##we source here the amended ComputeProbsdiff and hmm functions
source("computePvals.R")
source("computeposteriors.R")
suppressPackageStartupMessages({
library(BUMHMM)
library(Biostrings)
library(SummarizedExperiment) })
getwd()
setwd("/Users/toby/Desktop/BUM_HMM_analyses/diffhmmfwbw/version 0.2 - basic")
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+',stretches)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+',stretches)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+',stretches)
## ------------------------------------------------------------------------
dim(posteriors_diff)
print(posteriors_diff [1:4,])
View(posteriors)
View(posteriors_diff)
View(posteriors)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+',stretches)
source("https://bioconductor.org/biocLite.R")
##we source here the amended ComputeProbsdiff and hmm functions
source("computePvals.R")
source("computeposteriors.R")
#biocLite("BUMHMM")
#biocLite("Biostrings")
#install.packages("Rcpp", dependencies = TRUE)
suppressPackageStartupMessages({
library(BUMHMM)
library(Biostrings)
library(SummarizedExperiment) })
getwd()
setwd("/Users/toby/Desktop/BUM_HMM_analyses/diffhmmfwbw/version 0.2 - basic")
#make a table: take coverage counts and drop off counts from the working directory
mergedcounts <- read.table("35S_WT_readcounts.sgr", comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedstarts <- read.table("35S_WT_dropoffcounts.sgr",comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
head(mergedcounts)
#only selects a slice of the table: the columns with the coverage and DR counts
mergedcounts <- mergedcounts[3:6]
mergedstarts <- mergedstarts[3:6]
head(mergedcounts)
head(mergedstarts)
#calculate the drop off rates for each nucleotide position, drop off rates for treatment should be higher than control
mergeddors <- mergedstarts/mergedcounts
mergeddors <- replace(mergeddors,is.na(mergeddors),0)
head(mergeddors)
#introduce the reference DNA seqeunce, remove \r\n\ characters that can be found
#in size info of the file (although I have no idea why)
#store the reference sequence as a DNAString class object, under the name dna
#here its needed to specify the number of replicates we have for each control and treatment samples
refsequence <- "rDNA.seq"
seq <- gsub("[\r\n\"]", "",readChar(refsequence, file.info(refsequence)$size))
dna <- DNAString(seq)
noreplicates <- 2
#construct a list of matrices using the container SummarizedExperiment (se), containing DOC, coverage, and drop-off rate values.
#each column represents the samples: 1 column for each control or treatment replicate
#while each row represents features of interest we want to view: the nucleotide position along the reference DNA sequence
#the rep function gives a handle to extract data from the matrices
se <- SummarizedExperiment(
list(
coverage=as.matrix(mergedcounts),
dropoff_count=as.matrix(mergedstarts),
dropoff_rate=as.matrix(mergeddors)
), colData=DataFrame(
replicate=rep(c("control", "treatment"), each=noreplicates)
), rowData=DataFrame(
nucl=Views(dna, successiveIRanges(rep(1, nchar(dna))))
))
colnames(se) <- c('C1', 'C2', 'T1', 'T2')
se
##this is a test to see if we can get data for the specified experimental replicates (controls/treatments)
#for one of the matrices (coverage) we have contained in se
controls <- se[, se$replicate == "control"]
treatments <- se[, se$replicate == "treatment"]
head(assay(controls, 'coverage'))
head(assay(treatments, 'coverage'))
##This section selects nucleotide positions in each experimental replicate from which
#LDRs will be calculated, using the selectNuclPos function. It takes in the coverage
#and DOC info from se, the numbers of control (Nc) and treatment (Nt) replicates, and
#user-specified coverage threshold. Nucleotides with coverage < t are eliminated.
Nc <- Nt <- noreplicates
t <- 1
nuclSelection <- selectNuclPos(se, Nc, Nt, t)
List(nuclSelection)
##this is just a calculator that returns the combinations we can make
#of n elements when taken m at a time. Here it just means we want to find the number
#of comparisons we can make when there Nc replicates. It returns the indices of the
#replicates for each possible combination.
t(combn(Nc, 2))
##selectNuclPos returns lists that hold the positional information for the nucleotide
#pairs that can be used to compute log ratios, in analysedC and analysed CT
length(nuclSelection$analysedC[[1]])
length(nuclSelection$analysedCT[[1]])
## Finds the medians of original drop-off rates in each experimental replicate
apply(assay(se, 'dropoff_rate'), 2, median)
## This is a normalization strategy, to ensure the distribution of drop-off rates are
#similar between replicates. Here we scale drop-off rates of the nucleotides selected for pairwise
#comparisons to have a common median value.
assay(se, "dropoff_rate") <- scaleDOR(se, nuclSelection, Nc, Nt)
## just a print out to confirm if medians of scaled drop-off rates between
#replicates have become more similar
apply(assay(se, 'dropoff_rate'), 2, median)
## ------------------------------------------------------------------------
##The computeStretches function finds uninterrupted stretches of nucleotides to be
#used for calculation of posterior probabilites. It returns an IRanges object
#called "stretches", a matrix which contains the index ranges and width
#of the uninterrupted stretches.
stretchesone <- computeStretches(se, t)
## ------------------------------------------------------------------------
head(stretchesone)
#assay(se, 'dropoff_count')[1748,]
## ------------------------------------------------------------------------
#corrects the log-ratios for any dependency on coverage, to correct for coverage
#bias. This is also the part where the log drop-off ratios are calculated.
varStab <- stabiliseVariance(se, nuclSelection, Nc, Nt)
LDR_C <- varStab$LDR_C
LDR_CT <- varStab$LDR_CT
#storing the matrices according to condition
LDR_C_1 <- LDR_C
LDR_CT_1 <-LDR_CT
head(LDR_C)
head(LDR_C_1)
head(LDR_CT_1)
#prints out the null distribution histogram, the argument breaks is use to define
#number of bins we want to break the data up into
hist(LDR_C, breaks = 30, main = 'Null distribution of LDRs')
## ------------------------------------------------------------------------
###RUN ON SECOND DATASET
#make a table: take coverage counts and drop off counts from the working directory
mergedcounts <- read.table("35S_Erb1_readcounts.sgr", comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedstarts <- read.table("35S_Erb1_dropoffcounts.sgr",comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
head(mergedcounts)
#only selects a slice of the table: the columns with the coverage and DR counts
mergedcounts <- mergedcounts[3:6]
mergedstarts <- mergedstarts[3:6]
head(mergedcounts)
head(mergedstarts)
#calculate the drop off rates for each nucleotide position, drop off rates for treatment should be higher than control
mergeddors <- mergedstarts/mergedcounts
mergeddors <- replace(mergeddors,is.na(mergeddors),0)
head(mergeddors)
#introduce the reference DNA seqeunce, remove \r\n\ characters that can be found
#in size info of the file (although I have no idea why)
#store the reference sequence as a DNAString class object, under the name dna
#here its needed to specify the number of replicates we have for each control and treatment samples
refsequence <- "rDNA.seq"
seq <- gsub("[\r\n\"]", "",readChar(refsequence, file.info(refsequence)$size))
dna <- DNAString(seq)
noreplicates <- 2
#construct a list of matrices using the container SummarizedExperiment (se), containing DOC, coverage, and drop-off rate values.
#each column represents the samples: 1 column for each control or treatment replicate
#while each row represents features of interest we want to view: the nucleotide position along the reference DNA sequence
#the rep function gives a handle to extract data from the matrices
se <- SummarizedExperiment(
list(
coverage=as.matrix(mergedcounts),
dropoff_count=as.matrix(mergedstarts),
dropoff_rate=as.matrix(mergeddors)
), colData=DataFrame(
replicate=rep(c("control", "treatment"), each=noreplicates)
), rowData=DataFrame(
nucl=Views(dna, successiveIRanges(rep(1, nchar(dna))))
))
colnames(se) <- c('C1', 'C2', 'T1', 'T2')
se
##this is a test to see if we can get data for the specified experimental replicates (controls/treatments)
#for one of the matrices (coverage) we have contained in se
controls <- se[, se$replicate == "control"]
treatments <- se[, se$replicate == "treatment"]
head(assay(controls, 'coverage'))
head(assay(treatments, 'coverage'))
##This section selects nucleotide positions in each experimental replicate from which
#LDRs will be calculated, using the selectNuclPos function. It takes in the coverage
#and DOC info from se, the numbers of control (Nc) and treatment (Nt) replicates, and
#user-specified coverage threshold. Nucleotides with coverage < t are eliminated.
Nc <- Nt <- noreplicates
t <- 1
nuclSelection <- selectNuclPos(se, Nc, Nt, t)
List(nuclSelection)
##this is just a calculator that returns the combinations we can make
#of n elements when taken m at a time. Here it just means we want to find the number
#of comparisons we can make when there Nc replicates. It returns the indices of the
#replicates for each possible combination.
t(combn(Nc, 2))
##selectNuclPos returns lists that hold the positional information for the nucleotide
#pairs that can be used to compute log ratios, in analysedC and analysed CT
#the number of matrices printed out by calling nuclSelection$analysedC or CT,
#correspond to the number of C-C/T-C comparisons that can be made between replicates.
length(nuclSelection$analysedC[[1]])
length(nuclSelection$analysedCT[[1]])
## Finds the medians of original drop-off rates in each experimental replicate
apply(assay(se, 'dropoff_rate'), 2, median)
## This is a normalization strategy, to ensure the distribution of drop-off rates are
#similar between replicates. Here we scale drop-off rates of the nucleotides selected for pairwise
#comparisons to have a common median value.
assay(se, "dropoff_rate") <- scaleDOR(se, nuclSelection, Nc, Nt)
## just a print out to confirm if medians of scaled drop-off rates between
#replicates have become more similar
apply(assay(se, 'dropoff_rate'), 2, median)
## ------------------------------------------------------------------------
##The computeStretches function finds uninterrupted stretches of nucleotides to be
#used for calculation of posterior probabilites. It returns an IRanges object
#called "stretches", a matrix which contains the index ranges and width
#of the uninterrupted stretches.
stretchestwo <- computeStretches(se, t)
## ------------------------------------------------------------------------
head(stretchestwo)
#assay(se, 'dropoff_count')[1748,]
## ------------------------------------------------------------------------
#corrects the log-ratios for any dependency on coverage, to correct for coverage
#bias. This is also the part where the log drop-off ratios are calculated.
varStab <- stabiliseVariance(se, nuclSelection, Nc, Nt)
LDR_C <- varStab$LDR_C
LDR_CT <- varStab$LDR_CT
#storing the
LDR_C_2 <- LDR_C
LDR_CT_2 <-LDR_CT
head(LDR_C_2)
head(LDR_CT_2)
#prints out the null distribution histogram, the argument breaks is use to define
#number of bins we want to break the data up into
hist(LDR_C, breaks = 30, main = 'Null distribution of LDRs')
## ------------------------------------------------------------------------
#considering that immediate neighbours of a nucleotide can affect accessibility,
#we want to remove the effect of sequence on nucleotides' susceptibility
#to chemical modification.This is done by computing different null distributions
#for user-defined sequence patterns. This step is omitted for the 18S.
nuclNum <- 3
patterns <- nuclPerm(nuclNum)
patterns
## ------------------------------------------------------------------------
## Extract the DNA sequence
sequence <- subject(rowData(se)$nucl)
sequence
nuclPosition <- findPatternPos(patterns, sequence, '+')
patterns[[1]]
head(nuclPosition[[1]])
## ------------------------------------------------------------------------
#Skip to here for 18S. Here we are using all the nucleotide positions for constructing
#a single null distribution for quantifying drop-off rate variability. We specify
#nuclPosition list to contain 1 element ([1]), corresponding to the single stretch
#of reference DNA sequence
nuclPosition <- list()
nuclPosition[[1]] <- 2:nchar(sequence)
## Start of the stretch
nuclPosition[[1]][1]
## End of the stretch, gives the length of the stretch of nucleotides
nuclPosition[[1]][length(nuclPosition[[1]])]
## ------------------------------------------------------------------------
###check if the matrices of p-values can be called after the pipeline has been run twice
head(LDR_C_1)
head(LDR_CT_1)
head(LDR_C_2)
head(LDR_CT_2)
## ------------------------------------------------------------------------
###computes posterior probabilities of all nucleotides in the stretch specified above.
#This is the step where the null distributions and p-values are calculated as well.
#The most important arguments are the LDRs, the positions used to compute the
#null distribution, as well as the positional information of the selected stretches
#and nucleotide pairs where the LDRs were obtained
stretches <-overlapsRanges(stretchesone,stretchestwo)
head(stretches)
empPvals_1 <- computePvals(LDR_C_1, LDR_CT_1, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
empPvals_1 <- computePvals(LDR_C_1, LDR_CT_1, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
empPvals_2 <- computePvals(LDR_C_2, LDR_CT_2, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
index_1<-is.na(empPvals_1)
index_2<-is.na(empPvals_2)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+')
## ------------------------------------------------------------------------
dim(posteriors_diff)
print(posteriors_diff [1:4,])
View(posteriors_diff)
source("https://bioconductor.org/biocLite.R")
##we source here the amended ComputeProbsdiff and hmm functions
source("computePvals.R")
source("computeposteriors.R")
#biocLite("BUMHMM")
#biocLite("Biostrings")
#install.packages("Rcpp", dependencies = TRUE)
suppressPackageStartupMessages({
library(BUMHMM)
library(Biostrings)
library(SummarizedExperiment) })
empPvals_1 <- computePvals(LDR_C_1, LDR_CT_1, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
empPvals_2 <- computePvals(LDR_C_2, LDR_CT_2, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
index_1<-is.na(empPvals_1)
index_2<-is.na(empPvals_2)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+')
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+')
empPvals_1 <- computePvals(LDR_C_1, LDR_CT_1, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
empPvals_2 <- computePvals(LDR_C_2, LDR_CT_2, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
index_1<-is.na(empPvals_1)
index_2<-is.na(empPvals_2)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+')
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+')
source("computeposteriors.R")
stretches <-overlapsRanges(stretchesone,stretchestwo)
head(stretches)
empPvals_1 <- computePvals(LDR_C_1, LDR_CT_1, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
empPvals_2 <- computePvals(LDR_C_2, LDR_CT_2, Nc, Nt, '+', nuclPosition,
nuclSelection$analysedC, nuclSelection$analysedCT)
index_1<-is.na(empPvals_1)
index_2<-is.na(empPvals_2)
posteriors_diff <- computeposteriors(empPvals_1,empPvals_2,'+')
View(posteriors_diff)
## ------------------------------------------------------------------------
dim(posteriors_diff)
print(posteriors_diff [1:4,])
print(posteriors_diff [1:10,])
source("https://bioconductor.org/biocLite.R")
source("Functions/computePvals.R")
source("Functions/calculateLDRs.R")
source("Functions/hmmFwbw_differential_two_betas.R")
setwd("/Users/toby/Desktop/BUM_HMM_analyses/diffhmmfwbw/version 0.4 - working/")
source("https://bioconductor.org/biocLite.R")
source("Functions/computePvals.R")
source("Functions/calculateLDRs.R")
source("Functions/hmmFwbw_differential_two_betas.R")
source("Functions/betaParamsEM.R")
source("Functions/betaParamsMStep.R")
source("Functions/findPatternPos.R")
source("Functions/nuclPerm.R")
source("Functions/scaleDOR.R")
source("Functions/selectNuclPos.R")
source("Functions/computeStretches.R")
source("Functions/stabiliseVariance.R")
suppressPackageStartupMessages({
library(Biostrings)
library(SummarizedExperiment) })
#make a table: take coverage counts and drop off counts from the working directory
mergedcountswt <- read.table("Data/35S_WT_readcounts.sgr", comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedstartswt <- read.table("Data/35S_WT_dropoffcounts.sgr",comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedcountsmut <- read.table("Data/35S_Erb1_readcounts.sgr", comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedstartsmut <- read.table("Data/35S_Erb1_dropoffcounts.sgr",comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
logdropoffswt <- calculateLDRs(mergedcountswt,mergedstartswt)
#make a table: take coverage counts and drop off counts from the working directory
mergedcountswt <- read.table("Data/35S_WT_readcounts.sgr", comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedstartswt <- read.table("Data/35S_WT_dropoffcounts.sgr",comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedcountsmut <- read.table("Data/35S_Erb1_readcounts.sgr", comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
mergedstartsmut <- read.table("Data/35S_Erb1_dropoffcounts.sgr",comment.char="#",col.names=c("chromosome","position","35S_DMSO_1","35S_DMSO_2","35S_1M7_1","35S_1M7_2"))
logdropoffswt <- calculateLDRs(mergedcountswt,mergedstartswt)
logdropoffsmut <- calculateLDRs(mergedcountsmut,mergedstartsmut)
#prints out the null distribution histogram, the argument breaks is use to define
#number of bins we want to break the data up into
hist(logdropoffswt$LDR_C, breaks = 30, main = 'Null distribution of LDRs')
## ------------------------------------------------------------------------
###check if the matrices of p-values can be called after the pipeline has been run twice
head(logdropoffswt$LDR_C)
head(logdropoffswt$LDR_CT)
head(logdropoffsmut$LDR_C)
head(logdropoffsmut$LDR_CT)
Nc <- Nt <- 2
strand = "+"
###
empPvals_1 <- computePvals(logdropoffswt$LDR_C,logdropoffswt$LDR_CT, Nc, Nt, strand, logdropoffswt$nuclPosition,
logdropoffswt$nuclSelection$analysedC, logdropoffswt$nuclSelection$analysedCT)
empPvals_2 <- computePvals(logdropoffsmut$LDR_C,logdropoffsmut$LDR_CT, Nc, Nt, strand, logdropoffsmut$nuclPosition,
logdropoffsmut$nuclSelection$analysedC, logdropoffsmut$nuclSelection$analysedCT)
stretches <-overlapsRanges(logdropoffswt$stretches,logdropoffsmut$stretches)
stretches <-overlapsRanges(logdropoffswt$stretches,logdropoffsmut$stretches)
## Number of nucleotides in the sequence = number of rows in LDR_C
# *****perhaps its more appropriate to take the length of empPValues here???*****
nNucl <- length(empPvals_1[1, ])
posteriors_diff <- hmmFwbw_differential_two_betas(list(empPvals_1,empPvals_2))
colnames(posteriors_diff) <- c("UU","UM","MU","MM")
head(posteriors_diff)
## All posterior probabilities need to be shifted by 1 nt because the RT
## is believed to stop 1 nucleotide before the modified nucleodide.
## So below a new matrix is made containing the values shifted by one position.
## ------------------------------------------------------------------------
shifted_posteriors <- matrix(, nrow=dim(posteriors_diff)[1], ncol=4)
shifted_posteriors[1:(length(shifted_posteriors[,1]) - 1), ] <- posteriors_diff[2:(length(shifted_posteriors[,1])), ]
colnames(shifted_posteriors) <- c("UU","UM","MU","MM")
head(shifted_posteriors)
head(posteriors_diff)
differentiallymod <- shifted_posteriors[,2] + shifted_posteriors[,3]
## ------------------------------------------------------------------------
plot(differentiallymod, xlab = 'Nucleotide position',
ylab = 'Probability of modification',
main = 'BUMHMM output for 35S DMS data set',
ylim = c(0,1))
## ------------------------------------------------------------------------
shifted_posteriors <- replace(shifted_posteriors,is.na(shifted_posteriors),-999)
## ------------------------------------------------------------------------
plot(differentiallymod, xlab = 'Nucleotide position',
ylab = 'Probability of modification',
main = 'BUMHMM output for 35S DMS data set',
ylim = c(0,1))
## ------------------------------------------------------------------------
shifted_posteriors <- replace(shifted_posteriors,is.na(shifted_posteriors),-999)
write.table(shifted_posteriors,sep="\t",quote=FALSE,file="35S_diffBUM_HMM_WT_vs_Erb1_posteriors.txt",col.names = c("UU","UM","MU","MM"), row.names = TRUE)
